This patch is based on commit db13d9b8a13b82df71f199f20f03a24a4c5b8175. It has been modified by Metrological.

--- a/src/gui/opengl/qopengltextureglyphcache.cpp
+++ b/src/gui/opengl/qopengltextureglyphcache.cpp
@@ -302,11 +302,6 @@ void QOpenGLTextureGlyphCache::fillTexture(const Coord &c, glyph_t glyph, QFixed
     const int maskWidth = mask.width();
     const int maskHeight = mask.height();
 
-#if defined(QT_OPENGL_ES_2)
-    QOpenGLExtensions extensions(ctx);
-    bool hasBGRA = extensions.hasOpenGLExtension(QOpenGLExtensions::BGRATextureFormat);
-#endif
-
     if (mask.format() == QImage::Format_Mono) {
         mask = mask.convertToFormat(QImage::Format_Indexed8);
         for (int y = 0; y < maskHeight; ++y) {
@@ -318,9 +313,6 @@ void QOpenGLTextureGlyphCache::fillTexture(const Coord &c, glyph_t glyph, QFixed
         if (mask.format() == QImage::Format_RGB32
             // We need to make the alpha component equal to the average of the RGB values.
             // This is needed when drawing sub-pixel antialiased text on translucent targets.
-#if defined(QT_OPENGL_ES_2)
-            || !hasBGRA // We need to reverse the bytes
-#endif
             ) {
             for (int y = 0; y < maskHeight; ++y) {
                 quint32 *src = (quint32 *) mask.scanLine(y);
@@ -335,12 +327,10 @@ void QOpenGLTextureGlyphCache::fillTexture(const Coord &c, glyph_t glyph, QFixed
                         avg = src[x] >> 24;
 
 #if defined(QT_OPENGL_ES_2)
-                    if (!hasBGRA) {
-                        // Reverse bytes to match GL_RGBA
-                        src[x] = (avg << 24) | (quint32(r) << 0) | (quint32(g) << 8) | (quint32(b) << 16);
-                    } else
+                    // swizzle the bits to accommodate for the GL_RGBA upload.
+                    src[x] = (avg << 24) | (quint32(r) << 0) | (quint32(g) << 8) | (quint32(b) << 16);
 #endif
-                        src[x] = (src[x] & 0x00ffffff) | (avg << 24);
+                    src[x] = (src[x] & 0x00ffffff) | (avg << 24);
                 }
             }
         }
@@ -349,7 +339,7 @@ void QOpenGLTextureGlyphCache::fillTexture(const Coord &c, glyph_t glyph, QFixed
     glBindTexture(GL_TEXTURE_2D, m_textureResource->m_texture);
     if (mask.depth() == 32) {
 #if defined(QT_OPENGL_ES_2)
-        glTexSubImage2D(GL_TEXTURE_2D, 0, c.x, c.y, maskWidth, maskHeight, hasBGRA ? GL_BGRA_EXT : GL_RGBA, GL_UNSIGNED_BYTE, mask.bits());
+        glTexSubImage2D(GL_TEXTURE_2D, 0, c.x, c.y, maskWidth, maskHeight, GL_RGBA, GL_UNSIGNED_BYTE, mask.bits());
 #else
         glTexSubImage2D(GL_TEXTURE_2D, 0, c.x, c.y, maskWidth, maskHeight, GL_BGRA, GL_UNSIGNED_BYTE, mask.bits());
 #endif

--- a/src/opengl/gl2paintengineex/qtextureglyphcache_gl.cpp
+++ b/src/opengl/gl2paintengineex/qtextureglyphcache_gl.cpp
@@ -317,7 +317,12 @@ void QGLTextureGlyphCache::fillTexture(const Coord &c, glyph_t glyph, QFixed sub
                 uchar g = src[x] >> 8;
                 uchar b = src[x];
                 quint32 avg = (quint32(r) + quint32(g) + quint32(b) + 1) / 3; // "+1" for rounding.
+#if defined(QT_OPENGL_ES_2)
+                // swizzle the bits to accommodate for the GL_RGBA upload.
+                src[x] = (avg << 24) | (quint32(r) << 0) | (quint32(g) << 8) | (quint32(b) << 16);
+#else
                 src[x] = (src[x] & 0x00ffffff) | (avg << 24);
+#endif
             }
         }
     }
@@ -325,8 +330,7 @@ void QGLTextureGlyphCache::fillTexture(const Coord &c, glyph_t glyph, QFixed sub
     glBindTexture(GL_TEXTURE_2D, m_textureResource->m_texture);
     if (mask.format() == QImage::Format_RGB32) {
 #if defined(QT_OPENGL_ES_2)
-        // ###TODO Ensure extension is actually present on ES2
-        glTexSubImage2D(GL_TEXTURE_2D, 0, c.x, c.y, maskWidth, maskHeight, GL_BGRA_EXT, GL_UNSIGNED_BYTE, mask.bits());
+        glTexSubImage2D(GL_TEXTURE_2D, 0, c.x, c.y, maskWidth, maskHeight, GL_RGBA, GL_UNSIGNED_BYTE, mask.bits());
 #else
         glTexSubImage2D(GL_TEXTURE_2D, 0, c.x, c.y, maskWidth, maskHeight, GL_BGRA, GL_UNSIGNED_BYTE, mask.bits());
 #endif

